---
title: 'Scribble to Erase on Goodnotes for Windows, Web, and Android, Powered by ONNX Runtime'
date: '17th November, 2024'
description: 'Discover how Goodnotes brings the popular scribble-to-erase feature from iPad to Windows, Web, and Android with the help of ONNX Runtime, enabling seamless, high-performance AI integration across platforms.'
keywords: 'Goodnotes, scribble to erase, ONNX Runtime, AI model inference, cross-platform AI, Web AI, Windows AI, Android AI, web assembly, ONNX model, PWA, AI on device, Edge AI, AI feature integration'
authors: ['Pedro G√≥mez', 'Emma Ning']
authorsLink: ['https://x.com/pedro_g_s', 'https://www.linkedin.com/in/emma-qiong-ning-21b554236/']
image: 'https://iili.io/2nxtC57.png'
imageSquare: ''
url: 'https://onnxruntime.ai/blogs/goodnotes-scribble-to-erase'
---

<script>
    import Highlight from 'svelte-highlight';
    import typescript from 'svelte-highlight/languages/typescript';
    let code1 = `export class OnnxScribbleToEraseAIModel extends OnnxAIModel<Array<Array<number>>, EvaluationResult>

implements ScribbleToEraseAIModel
{
    getModelResource(): OnDemandResource {
        return OnDemandResource.ScribbleToErase;
    }


    async evaluateModel(input: Array<Array<number>>): Promise<EvaluationResult> {
        const startTime = performance.now();
        const { tensor, initializeTensorTime } = this.initializeTensor(input);
        const { evaluationScore, evaluateModelTime } = await this.runModel(tensor);
        const result = {
            score: evaluationScore ?? 0.0,
            timeToInitializeTensor: initializeTensorTime,
            timeToEvaluateTheModel: evaluateModelTime,
            totalExecutionTime: performance.now() - startTime,
        };
        return result;
    }
‚Ä¶..`
    let code2 = `private initializeTensor(input: number[][]) {
       const prepareTensorStartTime = performance.now();
       const modelInput = new Float32Array(input.flat());
       const tensor = new Tensor(modelInputTensorType, modelInput, modelInputDimensions);
       const initializeTensorTime = performance.now() - prepareTensorStartTime;
       return { tensor, initializeTensorTime };
   }


private async runModel(tensor: Tensor) {
    const evaluateModelStartTime = performance.now();
    const inferenceSession = this.session;
    const outputMap = await inferenceSession.run({ x: tensor });
    const outputTensor = outputMap[modelOutputName];
    const evaluationScore = outputTensor?.data[0] as number | undefined;
    const evaluateModelTime = performance.now() - evaluateModelStartTime;
    return { evaluationScore, evaluateModelTime };
}`
   const code3 = `ort.env.logLevel = 'fatal';
ort.env.wasm.wasmPaths = '/onnx/providers/wasm/';
this.session = await InferenceSession.create(modelURL);`
</script>

For the last three years, the Goodnotes engineering team has been working on a project to bring the successful iPad note-taking app to platforms like Windows, Web, and Android. This post covers how the 2022 iPad App of the Year implemented one of the top AI-requested features, scribble to erase, across these platforms using ONNX Runtime.

## üìù What is Scribble to Erase?

Mistakes are part of note-taking, and scribble to erase lets users delete content simply by scribbling over it. This intuitive gesture replaces the eraser tool and streamlines editing.

<div class="m-auto w50">
<img src="" alt="">
</div>
<br/>

Any note previously written can be deleted with a simple scribble. While the feature appears simple for users, it‚Äôs more complex from an engineering standpoint.

<div class="m-auto w50">
<img src="" alt="">
</div>
<br/>

This was the first AI-powered feature the Goodnotes team released for Windows, Web, and Android, thanks to [ONNX Runtime](https://onnxruntime.ai/docs/tutorials/web/), which enables high-performance model inference across platforms. The team used an in-house model evaluated on-device from all three platforms.

## üîç How Is a Scribble Detected?

In Goodnotes, a scribble gesture is simply a stroke in the document with a specific pattern. A stroke qualifies as a scribble if:

- It contains enough points.
- The AI model evaluated using ONNX Runtime recognizes it as a scribble.

For each new stroke, the team evaluates the stroke‚Äôs size and uses the AI model to determine if it qualifies as a scribble. The process follows a typical AI evaluation flow:

1. **Feature Extraction**: The team normalizes the note‚Äôs points and converts the stylus-generated data into a format the AI model can process.
2. **AI Model Evaluation**: The LSTM-based model, trained in-house, is deployed across platforms, allowing for on-device evaluation without internet.

After feature extraction, ONNX Runtime evaluates the model output. If the score is above a threshold, the stroke is considered a scribble, and all underlying content is deleted.

<div class="m-auto w50">
<img src="" alt="">
</div>
<br/>

## ü§ù Why ONNX Runtime?

The Goodnotes team needed a solution for evaluating the model across platforms, as the existing iOS version used CoreML, which isn‚Äôt available outside the Apple ecosystem.

<div class="m-auto w50">
<img src="" alt="">
</div>
<br/>

The tech stack for Windows, Web, and Android is based on web technologies, with Goodnotes implemented as a [Progressive Web Application](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps) (PWA) in full-screen native mode. Thus, the model evaluation solution had to be web-compatible and performant, enabling hardware acceleration where possible. After experimentation, the team chose ONNX Runtime. A [prototype](https://github.com/pedrovgs/HWEmoji) confirmed ONNX Runtime‚Äôs capabilities for the feature.

<div class="m-auto w50">
<img src="" alt="">
</div>
<br/>

The team selected ONNX Runtime for four reasons:

- The [prototype](https://github.com/pedrovgs/HWEmoji) demonstrated ease of integration and full required functionality.
- ONNX is a portable format, allowing model export from CoreML to other operating systems.
- [Execution providers](https://onnxruntime.ai/docs/execution-providers/) allow hardware acceleration, with WASM for CPU and WebNN and WebGPU for GPU/NPU.
- Compatibility with the LSTM model architecture.

## üíª ONNX Runtime Code Example

The core model evaluation code shares business logic with the iOS/Mac team, with processing handled via web assembly. For model evaluation, control switches to the web environment and ONNX Runtime.

An example of the ONNX Runtime code:

<Highlight language={typescript} code={code1} />

The implementation follows standard AI feature processing: data is fed to the model as a tensor, and output is checked against a threshold. Execution times are also logged for resource evaluation.

<Highlight language={typescript} code={code2} />

The model loads and runs in a Web Worker to minimize user impact during this critical user experience flow.

<Highlight language={typescript} code={code3} />

The CPU execution provider, powered by WASM, is used for this lightweight model. For future models, we‚Äôre considering WebGPU and WebNN execution providers.

## üöÄ Deployment and Integration

Due to Goodnotes‚Äô web-based tech stack, ONNX Runtime integration required adjustments. Goodnotes uses [Vite](https://vite.dev/), so they configured Vite to distribute both the model and necessary CPU execution resources. As a PWA, the app is usable offline, which necessitated including the model binary and ONNX Runtime resources in the bundle.

## üìà Results After Production Deployment

Since releasing scribble to erase, Goodnotes users have adopted it as a natural gesture. Since launch, the model has run nearly 2 billion evaluations. With the CPU execution provider and model running from a Web Worker, the P95 evaluation time is under 16 ms, and P99 is below 27 ms. The team is proud of these achievements, made possible by ONNX Runtime.