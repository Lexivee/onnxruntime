<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ONNX Runtime: onnxruntime::IExecutionProvider Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ONNX Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceonnxruntime.html">onnxruntime</a></li><li class="navelem"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html">IExecutionProvider</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classonnxruntime_1_1IExecutionProvider-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">onnxruntime::IExecutionProvider Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="execution__provider_8h_source.html">execution_provider.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for onnxruntime::IExecutionProvider:</div>
<div class="dyncontent">
<div class="center"><img src="classonnxruntime_1_1IExecutionProvider__inherit__graph.png" border="0" usemap="#onnxruntime_1_1IExecutionProvider_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a996806d27429056e13184d5ff4590d24"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a996806d27429056e13184d5ff4590d24">~IExecutionProvider</a> ()=default</td></tr>
<tr class="separator:a996806d27429056e13184d5ff4590d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d94e7e7bd716f636a7f64802376751"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceonnxruntime.html#a6cdac724c5dcefded3a63f08dae58fda">AllocatorPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a25d94e7e7bd716f636a7f64802376751">GetAllocatorMap</a> () const</td></tr>
<tr class="separator:a25d94e7e7bd716f636a7f64802376751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4911f5441a3bd940b0384bc5a334b92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceonnxruntime.html#a6cdac724c5dcefded3a63f08dae58fda">AllocatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#ab4911f5441a3bd940b0384bc5a334b92">GetAllocator</a> (int id, <a class="el" href="allocator__info_8h.html#add3f8ee3ff93395704abae71c30cab18">ONNXRuntimeMemType</a> mem_type) const</td></tr>
<tr class="separator:ab4911f5441a3bd940b0384bc5a334b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f17ba64b2355b26293a4cfc3fac376f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::unique_ptr&lt; <a class="el" href="structonnxruntime_1_1ComputationCapacity.html">ComputationCapacity</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a6f17ba64b2355b26293a4cfc3fac376f">GetCapability</a> (const <a class="el" href="classonnxruntime_1_1GraphViewer.html">onnxruntime::GraphViewer</a> &amp;graph_viewer, const std::vector&lt; const <a class="el" href="classonnxruntime_1_1KernelRegistry.html">KernelRegistry</a> *&gt; &amp;kernel_registries) const</td></tr>
<tr class="separator:a6f17ba64b2355b26293a4cfc3fac376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83caf9a8da9fcbc4e7fdc891055d664d"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classonnxruntime_1_1KernelRegistry.html">KernelRegistry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a83caf9a8da9fcbc4e7fdc891055d664d">GetKernelRegistry</a> () const =0</td></tr>
<tr class="separator:a83caf9a8da9fcbc4e7fdc891055d664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9bb47c0d2d72598ceb381688adfe26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a2b9bb47c0d2d72598ceb381688adfe26">CopyTensor</a> (const <a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;src, <a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;dst) const =0</td></tr>
<tr class="separator:a2b9bb47c0d2d72598ceb381688adfe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72d136c6a46bb4f33c9a877e01cccaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#ac72d136c6a46bb4f33c9a877e01cccaa">CopyTensor</a> (const <a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;src, <a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;dst, int exec_queue_id) const</td></tr>
<tr class="separator:ac72d136c6a46bb4f33c9a877e01cccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaeab04945539bc5db5942b63684ccb"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="mlasi_8h.html#a88f941d423cb2a819b70a1358982b1a6">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#aebaeab04945539bc5db5942b63684ccb">GetExecutionHandle</a> () const noexcept=0</td></tr>
<tr class="separator:aebaeab04945539bc5db5942b63684ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfeb7af172299bcc6083a418b01fac1"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a6bfeb7af172299bcc6083a418b01fac1">Type</a> () const =0</td></tr>
<tr class="separator:a6bfeb7af172299bcc6083a418b01fac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3657d5ed274547507a7b99d466fa13ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a3657d5ed274547507a7b99d466fa13ef">Sync</a> () const</td></tr>
<tr class="separator:a3657d5ed274547507a7b99d466fa13ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d724b727c4518125b5b154b481bccb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a0d724b727c4518125b5b154b481bccb3">OnRunStart</a> ()</td></tr>
<tr class="separator:a0d724b727c4518125b5b154b481bccb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4b49018ff2509a01c1dd73b5cbb811"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a2a4b49018ff2509a01c1dd73b5cbb811">OnRunEnd</a> ()</td></tr>
<tr class="separator:a2a4b49018ff2509a01c1dd73b5cbb811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625943e29574b9876f3d7c34e3fe882e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mlasi_8h.html#a88f941d423cb2a819b70a1358982b1a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classonnxruntime_1_1IExecutionProvider.html#a625943e29574b9876f3d7c34e3fe882e">InsertAllocator</a> (<a class="el" href="namespaceonnxruntime.html#a6cdac724c5dcefded3a63f08dae58fda">AllocatorPtr</a> allocator)</td></tr>
<tr class="separator:a625943e29574b9876f3d7c34e3fe882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a996806d27429056e13184d5ff4590d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996806d27429056e13184d5ff4590d24">&#9670;&nbsp;</a></span>~IExecutionProvider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual onnxruntime::IExecutionProvider::~IExecutionProvider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2b9bb47c0d2d72598ceb381688adfe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9bb47c0d2d72598ceb381688adfe26">&#9670;&nbsp;</a></span>CopyTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a> onnxruntime::IExecutionProvider::CopyTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy tensor between execution providers </p>

<p>Implemented in <a class="el" href="classonnxruntime_1_1CPUExecutionProvider.html#a6fc53592b62c7774860e59102df871f3">onnxruntime::CPUExecutionProvider</a>, <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a6f2ec2e4082683b6de03eeb48acbf546">onnxruntime::CUDAExecutionProvider</a>, and <a class="el" href="classonnxruntime_1_1MKLDNNExecutionProvider.html#a84adc2668cac60f53d2566e03b2080b0">onnxruntime::MKLDNNExecutionProvider</a>.</p>

</div>
</div>
<a id="ac72d136c6a46bb4f33c9a877e01cccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72d136c6a46bb4f33c9a877e01cccaa">&#9670;&nbsp;</a></span>CopyTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a> onnxruntime::IExecutionProvider::CopyTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classonnxruntime_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exec_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy tensor between execution providers on specified exec queue </p>

<p>Reimplemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a7238cead30fe69540b3df62e6913d579">onnxruntime::CUDAExecutionProvider</a>.</p>

</div>
</div>
<a id="ab4911f5441a3bd940b0384bc5a334b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4911f5441a3bd940b0384bc5a334b92">&#9670;&nbsp;</a></span>GetAllocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceonnxruntime.html#a6cdac724c5dcefded3a63f08dae58fda">AllocatorPtr</a> onnxruntime::IExecutionProvider::GetAllocator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="allocator__info_8h.html#add3f8ee3ff93395704abae71c30cab18">ONNXRuntimeMemType</a>&#160;</td>
          <td class="paramname"><em>mem_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get allocator with specified MemType </p>

<p>Reimplemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a01469a525b621ce14a85fcc8187847c4">onnxruntime::CUDAExecutionProvider</a>.</p>

</div>
</div>
<a id="a25d94e7e7bd716f636a7f64802376751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d94e7e7bd716f636a7f64802376751">&#9670;&nbsp;</a></span>GetAllocatorMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceonnxruntime.html#a6cdac724c5dcefded3a63f08dae58fda">AllocatorPtr</a>&gt; onnxruntime::IExecutionProvider::GetAllocatorMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all IAllocators for &lt;*this&gt; execution provider. </p>

</div>
</div>
<a id="a6f17ba64b2355b26293a4cfc3fac376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f17ba64b2355b26293a4cfc3fac376f">&#9670;&nbsp;</a></span>GetCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="structonnxruntime_1_1ComputationCapacity.html">ComputationCapacity</a> &gt; &gt; onnxruntime::IExecutionProvider::GetCapability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classonnxruntime_1_1GraphViewer.html">onnxruntime::GraphViewer</a> &amp;&#160;</td>
          <td class="paramname"><em>graph_viewer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classonnxruntime_1_1KernelRegistry.html">KernelRegistry</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_registries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get execution provider's capability for the specified &lt;graph&gt;. Return a bunch of IndexedSubGraphs &lt;*this&gt; execution provider can run if the sub-graph contains only one node or can fuse to run if the sub-graph contains more than one node. The node indexes contained in sub-graphs may have overlap, and it's ONNXRuntime's responsibility to do the partition and decide whether a node will be assigned to &lt;*this&gt; execution provider. </p>

<p>Reimplemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a1bb04dae34303befc1db6b487dc4c7c5">onnxruntime::CUDAExecutionProvider</a>, and <a class="el" href="classonnxruntime_1_1CPUExecutionProvider.html#a5c6c0ee34c9768248d2bcb5f5b0aea70">onnxruntime::CPUExecutionProvider</a>.</p>

</div>
</div>
<a id="aebaeab04945539bc5db5942b63684ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaeab04945539bc5db5942b63684ccb">&#9670;&nbsp;</a></span>GetExecutionHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="mlasi_8h.html#a88f941d423cb2a819b70a1358982b1a6">void</a>* onnxruntime::IExecutionProvider::GetExecutionHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an opaque handle whose exact type varies based on the provider and is interpreted accordingly by the corresponding kernel implementation. For Direct3D operator kernels, this may return an IUnknown supporting QueryInterface to ID3D12GraphicsCommandList1. </p>

<p>Implemented in <a class="el" href="classonnxruntime_1_1CPUExecutionProvider.html#a43c0400ad3529ffc272f5db39682e0f8">onnxruntime::CPUExecutionProvider</a>, <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a1cf09f277e0559c0e864fa6b0d39c898">onnxruntime::CUDAExecutionProvider</a>, and <a class="el" href="classonnxruntime_1_1MKLDNNExecutionProvider.html#a8e47e298e1b0d6bd0b8bde10d6e1d7e4">onnxruntime::MKLDNNExecutionProvider</a>.</p>

</div>
</div>
<a id="a83caf9a8da9fcbc4e7fdc891055d664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83caf9a8da9fcbc4e7fdc891055d664d">&#9670;&nbsp;</a></span>GetKernelRegistry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classonnxruntime_1_1KernelRegistry.html">KernelRegistry</a>&gt; onnxruntime::IExecutionProvider::GetKernelRegistry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get kernel registry per execution provider type. The <a class="el" href="classonnxruntime_1_1KernelRegistry.html">KernelRegistry</a> share pointer returned is shared across sessions.</p>
<p>NOTE: this is a tricky but final solution to achieve following goals,</p><ol type="1">
<li>The execution provider type based kernel registry should be shared across sessions. Only one copy of this kind of kernel registry exists in ONNXRuntime with multiple sessions/models.</li>
<li>Adding an execution provider into ONNXRuntime does not need to touch ONNXRuntime frameowrk/session code.</li>
<li>onnxruntime runtime (framework/session) does not depend on any specific execution provider lib. </li>
</ol>

<p>Implemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a771c4dbe04b51b0c019e8b0e4648f61c">onnxruntime::CUDAExecutionProvider</a>, <a class="el" href="classonnxruntime_1_1CPUExecutionProvider.html#a549e5e72c5c08a72a3e4a00b5e872f23">onnxruntime::CPUExecutionProvider</a>, and <a class="el" href="classonnxruntime_1_1MKLDNNExecutionProvider.html#ad6f1e4b2ef0355a8f6b9c8fd866257ef">onnxruntime::MKLDNNExecutionProvider</a>.</p>

</div>
</div>
<a id="a625943e29574b9876f3d7c34e3fe882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625943e29574b9876f3d7c34e3fe882e">&#9670;&nbsp;</a></span>InsertAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mlasi_8h.html#a88f941d423cb2a819b70a1358982b1a6">void</a> onnxruntime::IExecutionProvider::InsertAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceonnxruntime.html#a6cdac724c5dcefded3a63f08dae58fda">AllocatorPtr</a>&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a4b49018ff2509a01c1dd73b5cbb811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4b49018ff2509a01c1dd73b5cbb811">&#9670;&nbsp;</a></span>OnRunEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a> onnxruntime::IExecutionProvider::OnRunEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when <a class="el" href="classonnxruntime_1_1InferenceSession.html#a90aa8b5fdc2638c4d2c45afc9c3ed222">InferenceSession::Run</a> ended NOTE that due to async execution in provider, the actual work of this Run may not be finished on device This function should be regarded as the point that all commands of current Run has been submmited by CPU </p>

<p>Reimplemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#aad4464387bb09d2337e334d5a7325e5d">onnxruntime::CUDAExecutionProvider</a>.</p>

</div>
</div>
<a id="a0d724b727c4518125b5b154b481bccb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d724b727c4518125b5b154b481bccb3">&#9670;&nbsp;</a></span>OnRunStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a> onnxruntime::IExecutionProvider::OnRunStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when <a class="el" href="classonnxruntime_1_1InferenceSession.html#a90aa8b5fdc2638c4d2c45afc9c3ed222">InferenceSession::Run</a> started NOTE that due to async execution in provider, the actual work of previous Run may not be finished on device This function should be regarded as the point after which a new Run would start to submit commands from CPU </p>

<p>Reimplemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#abf7e482aba687b89fcbd6586271ca753">onnxruntime::CUDAExecutionProvider</a>.</p>

</div>
</div>
<a id="a3657d5ed274547507a7b99d466fa13ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3657d5ed274547507a7b99d466fa13ef">&#9670;&nbsp;</a></span>Sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classonnxruntime_1_1common_1_1Status.html">common::Status</a> onnxruntime::IExecutionProvider::Sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until the device has completed all preceding requested tasks. Currently this is primarily used by the <a class="el" href="classonnxruntime_1_1IOBinding.html">IOBinding</a> object to ensure that all inputs have been copied to the device before execution begins. </p>

<p>Reimplemented in <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#a4f3479126d1191bb1074c4b953b3ef87">onnxruntime::CUDAExecutionProvider</a>.</p>

</div>
</div>
<a id="a6bfeb7af172299bcc6083a418b01fac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfeb7af172299bcc6083a418b01fac1">&#9670;&nbsp;</a></span>Type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string onnxruntime::IExecutionProvider::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>type of the execution provider; should match that set in the node through the SetExecutionProvider API. Example valid return values are: kCpuExecutionProvider, kCudaExecutionProvider </dd></dl>

<p>Implemented in <a class="el" href="classonnxruntime_1_1CPUExecutionProvider.html#a419ca314cd97d0561226e90755b29da2">onnxruntime::CPUExecutionProvider</a>, <a class="el" href="classonnxruntime_1_1CUDAExecutionProvider.html#aba2225328bd739b5e6ef4be06557985b">onnxruntime::CUDAExecutionProvider</a>, and <a class="el" href="classonnxruntime_1_1MKLDNNExecutionProvider.html#a9d13e248253f882664260bb3e7d093b9">onnxruntime::MKLDNNExecutionProvider</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>onnxruntime/include/onnxruntime/core/framework/<a class="el" href="execution__provider_8h_source.html">execution_provider.h</a></li>
<li>onnxruntime/onnxruntime/core/framework/<a class="el" href="execution__provider_8cc.html">execution_provider.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
