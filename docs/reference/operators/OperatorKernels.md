---
title: Supported Operators and data types
parent: Operators
grand_parent: Reference
nav_order: 1
---

## Supported Operators and Data Types
*This file is automatically generated from the registered kernels by [this script](https://github.com/microsoft/onnxruntime/tree/master//tools/python/gen_opkernel_doc.py).
Do not modify directly.*

## Operators implemented by CPUExecutionProvider

| Op Name | Parameters | OpSet Version | Types Supported |
|---------|------------|---------------|-----------------|
|**Operator Domain:** *ai.onnx*||||
|Abs|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[6, 12]|**T** = tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Acos|*in* input:**T**<br/> *out* output:**T**|7+|**T** = tensor(float)|
|Acosh|*in* input:**T**<br/> *out* output:**T**|9+|**T** = tensor(float)|
|Add|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|14+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||13|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[7, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|Affine|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|And|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|7+|**T** = tensor(bool)<br/> **T1** = tensor(bool)|
|ArgMax|*in* data:**T**<br/> *out* reduced:**tensor(int64)**|13+|**T** = tensor(double), tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(float), tensor(int32)|
|ArgMin|*in* data:**T**<br/> *out* reduced:**tensor(int64)**|13+|**T** = tensor(double), tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(float), tensor(int32)|
|Asin|*in* input:**T**<br/> *out* output:**T**|7+|**T** = tensor(float)|
|Asinh|*in* input:**T**<br/> *out* output:**T**|9+|**T** = tensor(float)|
|Atan|*in* input:**T**<br/> *out* output:**T**|7+|**T** = tensor(float)|
|Atanh|*in* input:**T**<br/> *out* output:**T**|9+|**T** = tensor(float)|
|AveragePool|*in* X:**T**<br/> *out* Y:**T**|11+|**T** = tensor(float)|
|||10|**T** = tensor(float)|
|||[7, 9]|**T** = tensor(float)|
|AveragePoolGrad|*in* dY:**T**<br/> *out* dX:**T**|9+|**T** = tensor(float)|
|BatchNormalization|*in* X:**T**<br/> *in* scale:**T**<br/> *in* B:**T**<br/> *in* input_mean:**U**<br/> *in* input_var:**U**<br/> *out* Y:**T**<br/> *out* running_mean:**U**<br/> *out* running_var:**U**<br/> or<br/> *in* X:**T**<br/> *in* scale:**T**<br/> *in* B:**T**<br/> *in* mean:**T**<br/> *in* var:**T**<br/> *out* Y:**T**<br/> *out* mean:**T**<br/> *out* var:**T**<br/> *out* saved_mean:**T**<br/> *out* saved_var:**T**|14+|**T** = tensor(double), tensor(float)|
|||[9, 13]|**T** = tensor(double), tensor(float)|
|||[7, 8]|**T** = tensor(double), tensor(float)|
|BitShift|*in* X:**T**<br/> *in* Y:**T**<br/> *out* Z:**T**|11+|**T** = tensor(uint32), tensor(uint64), tensor(uint8)|
|Cast|*in* input:**T1**<br/> *out* output:**T2**|13+|**T1** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T2** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[6, 12]|**T1** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T2** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Ceil|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(float)|
|||[6, 12]|**T** = tensor(float)|
|Celu|*in* X:**T**<br/> *out* Y:**T**|12+|**T** = tensor(float)|
|Clip|*in* input:**T**<br/> *in* min:**T**<br/> *in* max:**T**<br/> *out* output:**T**<br/> or<br/> *in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float), tensor(int64), tensor(int8), tensor(uint64), tensor(uint8)|
|||12|**T** = tensor(double), tensor(float), tensor(int64), tensor(int8), tensor(uint64), tensor(uint8)|
|||11|**T** = tensor(float)|
|||[6, 10]|**T** = tensor(float)|
|Compress|*in* input:**T**<br/> *in* condition:**T1**<br/> *out* output:**T**|11+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(bool)|
|||[9, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(bool)|
|Concat|*in* inputs:**T**<br/> *out* concat_result:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[4, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|ConcatFromSequence|*in* input_sequence:**S**<br/> *out* concat_result:**T**|11+|**S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))|
|ConstantOfShape|*in* input:**T1**<br/> *out* output:**T2**|9+|**T1** = tensor(int64)<br/> **T2** = tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Conv|*in* X:**T**<br/> *in* W:**T**<br/> *in* B:**T**<br/> *out* Y:**T**|11+|**T** = tensor(float)|
|||[1, 10]|**T** = tensor(float)|
|ConvInteger|*in* x:**T1**<br/> *in* w:**T2**<br/> *in* x_zero_point:**T1**<br/> *in* w_zero_point:**T2**<br/> *out* y:**T3**|10+|**T1** = tensor(uint8)<br/> **T2** = tensor(uint8)<br/> **T3** = tensor(int32)|
|ConvTranspose|*in* X:**T**<br/> *in* W:**T**<br/> *in* B:**T**<br/> *out* Y:**T**|11+|**T** = tensor(float)|
|||[1, 10]|**T** = tensor(float)|
|Cos|*in* input:**T**<br/> *out* output:**T**|7+|**T** = tensor(float)|
|Cosh|*in* input:**T**<br/> *out* output:**T**|9+|**T** = tensor(float)|
|Crop|*in* input:**T**<br/> *out* output:**T**|1+|**T** = tensor(float)|
|CumSum|*in* x:**T**<br/> *in* axis:**T2**<br/> *out* y:**T**|14+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(int32), tensor(int64)|
|||[11, 13]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(int32), tensor(int64)|
|DepthToSpace|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(float)|
|||[11, 12]|**T** = tensor(float)|
|||[1, 10]|**T** = tensor(float)|
|DequantizeLinear|*in* x:**T**<br/> *in* x_scale:**tensor(float)**<br/> *in* x_zero_point:**T**<br/> *out* y:**tensor(float)**|13+|**T** = tensor(int32), tensor(int8), tensor(uint8)|
|||[10, 12]|**T** = tensor(int32), tensor(int8), tensor(uint8)|
|Det|*in* X:**T**<br/> *out* Y:**T**|11+|**T** = tensor(float)|
|Div|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|14+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||13|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[7, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|Dropout|*in* data:**T**<br/> *in* ratio:**T1**<br/> *in* training_mode:**T2**<br/> *out* output:**T**<br/> *out* mask:**T2**<br/> or<br/> *in* data:**T**<br/> *out* output:**T**<br/> *out* mask:**T**<br/> or<br/> *in* data:**T**<br/> *out* output:**T**<br/> *out* mask:**T1**|13+|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(double), tensor(float)<br/> **T2** = tensor(bool)|
|||12|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(double), tensor(float)<br/> **T2** = tensor(bool)|
|||[10, 11]|**T** = tensor(double), tensor(float), tensor(float16)<br/> **T1** = tensor(bool)|
|||[7, 9]|**T** = tensor(double), tensor(float), tensor(float16)<br/> **T1** = tensor(bool)|
|DynamicQuantizeLinear|*in* x:**T1**<br/> *out* y:**T2**<br/> *out* y_scale:**tensor(float)**<br/> *out* y_zero_point:**T2**|11+|**T2** = tensor(uint8)|
|DynamicSlice|*in* data:**T**<br/> *in* starts:**Tind**<br/> *in* ends:**Tind**<br/> *in* axes:**Tind**<br/> *out* output:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|Einsum|*in* Inputs:**T**<br/> *out* Output:**T**|12+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|Elu|*in* X:**T**<br/> *out* Y:**T**|6+|**T** = tensor(float)|
|Equal|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|13+|**T** = tensor(bool), tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|||[11, 12]|**T** = tensor(bool), tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|||[7, 10]|**T** = tensor(bool), tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|Erf|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(float)|
|||[9, 12]|**T** = tensor(float)|
|Exp|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|Expand|*in* input:**T**<br/> *in* shape:**tensor(int64)**<br/> *out* output:**T**|13+|**T** = tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[8, 12]|**T** = tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|EyeLike|*in* input:**T1**<br/> *out* output:**T2**|9+|**T1** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(uint64)<br/> **T2** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(uint64)|
|Flatten|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[9, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 8]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Floor|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(float)|
|||[6, 12]|**T** = tensor(float)|
|GRU|*in* X:**T**<br/> *in* W:**T**<br/> *in* R:**T**<br/> *in* B:**T**<br/> *in* sequence_lens:**T1**<br/> *in* initial_h:**T**<br/> *out* Y:**T**<br/> *out* Y_h:**T**|14+|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(int32)|
|||[7, 13]|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(int32)|
|Gather|*in* data:**T**<br/> *in* indices:**Tind**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||[1, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|GatherElements|*in* data:**T**<br/> *in* indices:**Tind**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|GatherND|*in* data:**T**<br/> *in* indices:**Tind**<br/> *out* output:**T**<br/> or<br/> *in* data:**T**<br/> *in* indices:**tensor(int64)**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int64)|
|||12|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int64)|
|||11|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int64)|
|Gemm|*in* A:**T**<br/> *in* B:**T**<br/> *in* C:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float)|
|||[11, 12]|**T** = tensor(double), tensor(float)|
|||[9, 10]|**T** = tensor(double), tensor(float)|
|||[7, 8]|**T** = tensor(double), tensor(float)|
|GlobalAveragePool|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|GlobalLpPool|*in* X:**T**<br/> *out* Y:**T**|2+|**T** = tensor(float)|
|GlobalMaxPool|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Greater|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|||[9, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|||[7, 8]|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(bool)|
|GreaterOrEqual|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|12+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|HardSigmoid|*in* X:**T**<br/> *out* Y:**T**|6+|**T** = tensor(float)|
|Hardmax|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(float)|
|||[11, 12]|**T** = tensor(float)|
|||[1, 10]|**T** = tensor(float)|
|Identity|*in* input:**T**<br/> *out* output:**T**<br/> or<br/> *in* input:**V**<br/> *out* output:**V**|14+|**V** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8)), tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||13|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|If|*in* cond:**B**<br/> *out* outputs:**V**|13+|**B** = tensor(bool)<br/> **V** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8)), tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**B** = tensor(bool)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 10]|**B** = tensor(bool)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|ImageScaler|*in* input:**T**<br/> *out* output:**T**|1+|**T** = tensor(float)|
|InstanceNormalization|*in* input:**T**<br/> *in* scale:**T**<br/> *in* B:**T**<br/> *out* output:**T**|6+|**T** = tensor(float)|
|IsInf|*in* X:**T1**<br/> *out* Y:**T2**|10+|**T1** = tensor(double), tensor(float)<br/> **T2** = tensor(bool)|
|IsNaN|*in* X:**T1**<br/> *out* Y:**T2**|13+|**T1** = tensor(float), tensor(float16)<br/> **T2** = tensor(bool)|
|||[9, 12]|**T1** = tensor(float), tensor(float16)<br/> **T2** = tensor(bool)|
|LRN|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(float)|
|||[1, 12]|**T** = tensor(float)|
|LSTM|*in* X:**T**<br/> *in* W:**T**<br/> *in* R:**T**<br/> *in* B:**T**<br/> *in* sequence_lens:**T1**<br/> *in* initial_h:**T**<br/> *in* initial_c:**T**<br/> *in* P:**T**<br/> *out* Y:**T**<br/> *out* Y_h:**T**<br/> *out* Y_c:**T**|14+|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(int32)|
|||[7, 13]|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(int32)|
|LayerNormalization|*in* X:**T**<br/> *in* Scale:**T**<br/> *in* B:**T**<br/> *out* Y:**T**<br/> *out* Mean:**U**<br/> *out* InvStdDev:**U**|1+|**T** = tensor(double), tensor(float)|
|LeakyRelu|*in* X:**T**<br/> *out* Y:**T**|6+|**T** = tensor(float)|
|Less|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|||[9, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|||[7, 8]|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(bool)|
|LessOrEqual|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|12+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(bool)|
|Log|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|LogSoftmax|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float)|
|||[11, 12]|**T** = tensor(double), tensor(float)|
|||[1, 10]|**T** = tensor(double), tensor(float)|
|Loop|*in* M:**I**<br/> *in* cond:**B**<br/> *in* v_initial:**V**<br/> *out* v_final_and_scan_outputs:**V**|13+|**B** = tensor(bool)<br/> **I** = tensor(int64)<br/> **V** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8)), tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**B** = tensor(bool)<br/> **I** = tensor(int64)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 10]|**B** = tensor(bool)<br/> **I** = tensor(int64)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|LpNormalization|*in* input:**T**<br/> *out* output:**T**|1+|**T** = tensor(double), tensor(float)|
|LpPool|*in* X:**T**<br/> *out* Y:**T**|11+|**T** = tensor(float)|
|||[2, 10]|**T** = tensor(float)|
|MatMul|*in* A:**T**<br/> *in* B:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)|
|||[9, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)|
|||[1, 8]|**T** = tensor(double), tensor(float)|
|MatMulInteger|*in* A:**T1**<br/> *in* B:**T2**<br/> *in* a_zero_point:**T1**<br/> *in* b_zero_point:**T2**<br/> *out* Y:**T3**|10+|**T1** = tensor(uint8)<br/> **T2** = tensor(int8), tensor(uint8)<br/> **T3** = tensor(int32)|
|Max|*in* data_0:**T**<br/> *out* max:**T**|13+|**T** = tensor(double), tensor(float), tensor(float16), tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)|
|||12|**T** = tensor(double), tensor(float), tensor(float16), tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)|
|||[8, 11]|**T** = tensor(double), tensor(float)|
|||[6, 7]|**T** = tensor(float)|
|MaxPool|*in* X:**T**<br/> *out* Y:**T**<br/> or<br/> *in* X:**T**<br/> *out* Y:**T**<br/> *out* Indices:**I**|12+|**I** = tensor(int64)<br/> **T** = tensor(double), tensor(float), tensor(int8), tensor(uint8)|
|||[8, 11]|**I** = tensor(int64)<br/> **T** = tensor(double), tensor(float)|
|||[1, 7]|**T** = tensor(float)|
|MaxPoolGrad|*in* dY:**T**<br/> *in* Indices:**I**<br/> *out* dX:**T**|9+|**T** = tensor(float)|
|MaxRoiPool|*in* X:**T**<br/> *in* rois:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|MaxUnpool|*in* X:**T1**<br/> *in* I:**T2**<br/> *in* output_shape:**T2**<br/> *out* output:**T1**|11+|**T1** = tensor(float)<br/> **T2** = tensor(int64)|
|||[9, 10]|**T1** = tensor(float)<br/> **T2** = tensor(int64)|
|Mean|*in* data_0:**T**<br/> *out* mean:**T**|13+|**T** = tensor(float)|
|||[8, 12]|**T** = tensor(float)|
|||[6, 7]|**T** = tensor(float)|
|MeanVarianceNormalization|*in* X:**T**<br/> *out* Y:**T**<br/> or<br/> *in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(float)|
|||[9, 12]|**T** = tensor(float)|
|||[1, 8]|**T** = tensor(float)|
|Min|*in* data_0:**T**<br/> *out* min:**T**|13+|**T** = tensor(double), tensor(float), tensor(float16), tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)|
|||12|**T** = tensor(double), tensor(float), tensor(float16), tensor(int32), tensor(int64), tensor(uint32), tensor(uint64)|
|||[8, 11]|**T** = tensor(double), tensor(float)|
|||[6, 7]|**T** = tensor(float)|
|Mod|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|13+|**T** = tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[10, 12]|**T** = tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Mul|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|14+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||13|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[7, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|Multinomial|*in* input:**T1**<br/> *out* output:**T2**|7+|**T1** = tensor(float)<br/> **T2** = tensor(int32), tensor(int64)|
|Neg|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8)|
|||[6, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8)|
|NonZero|*in* X:**T**<br/> *out* Y:**tensor(int64)**|13+|**T** = tensor(bool), tensor(float), tensor(int32), tensor(int64), tensor(uint8)|
|||[9, 12]|**T** = tensor(bool), tensor(float), tensor(int32), tensor(int64), tensor(uint8)|
|Not|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(bool)<br/> **T1** = tensor(bool)|
|OneHot|*in* indices:**T1**<br/> *in* depth:**T2**<br/> *in* values:**T3**<br/> *out* output:**T3**|11+|**T1** = tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(float), tensor(int32), tensor(int64)<br/> **T3** = tensor(float), tensor(int32), tensor(int64), tensor(string)|
|||[9, 10]|**T1** = tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(float), tensor(int32), tensor(int64)<br/> **T3** = tensor(float), tensor(int32), tensor(int64), tensor(string)|
|Or|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|7+|**T** = tensor(bool)<br/> **T1** = tensor(bool)|
|PRelu|*in* X:**T**<br/> *in* slope:**T**<br/> *out* Y:**T**|9+|**T** = tensor(float)|
|||[7, 8]|**T** = tensor(float)|
|Pad|*in* data:**T**<br/> *in* pads:**tensor(int64)**<br/> *in* constant_value:**T**<br/> *out* output:**T**<br/> or<br/> *in* data:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[2, 10]|**T** = tensor(double), tensor(float)|
|ParametricSoftplus|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Pow|*in* X:**T**<br/> *in* Y:**T**<br/> *out* Z:**T**<br/> or<br/> *in* X:**T**<br/> *in* Y:**T1**<br/> *out* Z:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||12|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T1** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[7, 11]|**T** = tensor(double), tensor(float)|
|QLinearConv|*in* x:**T1**<br/> *in* x_scale:**tensor(float)**<br/> *in* x_zero_point:**T1**<br/> *in* w:**T2**<br/> *in* w_scale:**tensor(float)**<br/> *in* w_zero_point:**T2**<br/> *in* y_scale:**tensor(float)**<br/> *in* y_zero_point:**T3**<br/> *in* B:**T4**<br/> *out* y:**T3**|10+|**T1** = tensor(uint8)<br/> **T2** = tensor(int8), tensor(uint8)<br/> **T3** = tensor(uint8)<br/> **T4** = tensor(int32)|
|QLinearMatMul|*in* a:**T1**<br/> *in* a_scale:**tensor(float)**<br/> *in* a_zero_point:**T1**<br/> *in* b:**T2**<br/> *in* b_scale:**tensor(float)**<br/> *in* b_zero_point:**T2**<br/> *in* y_scale:**tensor(float)**<br/> *in* y_zero_point:**T3**<br/> *out* y:**T3**|10+|**T1** = tensor(uint8)<br/> **T2** = tensor(int8), tensor(uint8)<br/> **T3** = tensor(uint8)|
|QuantizeLinear|*in* x:**T1**<br/> *in* y_scale:**tensor(float)**<br/> *in* y_zero_point:**T2**<br/> *out* y:**T2**|13+|**T1** = tensor(float)<br/> **T2** = tensor(int8), tensor(uint8)|
|||[10, 12]|**T1** = tensor(float)<br/> **T2** = tensor(int8), tensor(uint8)|
|RNN|*in* X:**T**<br/> *in* W:**T**<br/> *in* R:**T**<br/> *in* B:**T**<br/> *in* sequence_lens:**T1**<br/> *in* initial_h:**T**<br/> *out* Y:**T**<br/> *out* Y_h:**T**|14+|**T** = tensor(float)<br/> **T1** = tensor(int32)|
|||[7, 13]|**T** = tensor(float)<br/> **T1** = tensor(int32)|
|RandomNormal|*out* output:**T**|1+|**T** = tensor(double), tensor(float)|
|RandomNormalLike|*in* input:**T1**<br/> *out* output:**T2**|1+|**T1** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T2** = tensor(double), tensor(float)|
|RandomUniform|*out* output:**T**|1+|**T** = tensor(double), tensor(float)|
|RandomUniformLike|*in* input:**T1**<br/> *out* output:**T2**|1+|**T1** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T2** = tensor(double), tensor(float)|
|Range|*in* start:**T**<br/> *in* limit:**T**<br/> *in* delta:**T**<br/> *out* output:**T**|11+|**T** = tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64)|
|Reciprocal|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|ReduceL1|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(float), tensor(int32)|
|ReduceL2|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(float), tensor(int32)|
|ReduceLogSum|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(float), tensor(int32)|
|ReduceLogSumExp|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(double), tensor(float), tensor(int32)|
|ReduceMax|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8), tensor(uint8)|
|||12|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8), tensor(uint8)|
|||11|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[1, 10]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|ReduceMean|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(double), tensor(float), tensor(int32)|
|ReduceMin|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8), tensor(uint8)|
|||12|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(int8), tensor(uint8)|
|||11|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[1, 10]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|ReduceProd|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(float), tensor(int32), tensor(int64)|
|||[11, 12]|**T** = tensor(float), tensor(int32), tensor(int64)|
|||[1, 10]|**T** = tensor(float), tensor(int32), tensor(int64)|
|ReduceSum|*in* data:**T**<br/> *in* axes:**tensor(int64)**<br/> *out* reduced:**T**<br/> or<br/> *in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[1, 10]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|ReduceSumSquare|*in* data:**T**<br/> *out* reduced:**T**|13+|**T** = tensor(double), tensor(float), tensor(int32)|
|||[11, 12]|**T** = tensor(double), tensor(float), tensor(int32)|
|||[1, 10]|**T** = tensor(double), tensor(float), tensor(int32)|
|Relu|*in* X:**T**<br/> *out* Y:**T**|14+|**T** = tensor(double), tensor(float)|
|||13|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|Reshape|*in* data:**T**<br/> *in* shape:**tensor(int64)**<br/> *out* reshaped:**T**<br/> or<br/> *in* data:**T**<br/> *out* reshaped:**T**|14+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **shape** = tensor(int64)|
|||13|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **shape** = tensor(int64)|
|||[5, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **shape** = tensor(int64)|
|||[1, 4]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Resize|*in* X:**T**<br/> *in* scales:**tensor(float)**<br/> *out* Y:**T**<br/> or<br/> *in* X:**T1**<br/> *in* roi:**T2**<br/> *in* scales:**tensor(float)**<br/> *in* sizes:**tensor(int64)**<br/> *out* Y:**T1**|13+|**T1** = tensor(float), tensor(int32), tensor(uint8)|
|||[11, 12]|**T1** = tensor(float), tensor(int32), tensor(uint8)|
|||10|**T** = tensor(float), tensor(int32), tensor(uint8)|
|ReverseSequence|*in* input:**T**<br/> *in* sequence_lens:**tensor(int64)**<br/> *out* Y:**T**|10+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|RoiAlign|*in* X:**T1**<br/> *in* rois:**T1**<br/> *in* batch_indices:**T2**<br/> *out* Y:**T1**|10+|**T** = tensor(double), tensor(float)<br/> **T2** = tensor(int64)|
|Round|*in* X:**T**<br/> *out* Y:**T**|11+|**T** = tensor(double), tensor(float), tensor(float16)|
|Scale|*in* input:**T**<br/> *out* output:**T**|1+|**T** = tensor(float)|
|ScaledTanh|*in* input:**T**<br/> *out* output:**T**|1+|**T** = tensor(float)|
|Scan|*in* initial_state_and_scan_inputs:**V**<br/> *out* final_state_and_scan_outputs:**V**<br/> or<br/> *in* sequence_lens:**I**<br/> *in* initial_state_and_scan_inputs:**V**<br/> *out* final_state_and_scan_outputs:**V**|11+|**I** = tensor(int64)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[9, 10]|**I** = tensor(int64)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||8|**I** = tensor(int64)<br/> **V** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Scatter|*in* data:**T**<br/> *in* indices:**Tind**<br/> *in* updates:**T**<br/> *out* output:**T**|[9, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|ScatterElements|*in* data:**T**<br/> *in* indices:**Tind**<br/> *in* updates:**T**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|ScatterND|*in* data:**T**<br/> *in* indices:**tensor(int64)**<br/> *in* updates:**T**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Selu|*in* X:**T**<br/> *out* Y:**T**|6+|**T** = tensor(float)|
|SequenceAt|*in* input_sequence:**S**<br/> *in* position:**I**<br/> *out* tensor:**T**|11+|**I** = tensor(int32), tensor(int64)<br/> **S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))<br/> **T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|SequenceConstruct|*in* inputs:**T**<br/> *out* output_sequence:**S**|11+|**S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))<br/> **T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|SequenceEmpty|*out* output:**S**|11+|**S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))|
|SequenceErase|*in* input_sequence:**S**<br/> *in* position:**I**<br/> *out* output_sequence:**S**|11+|**I** = tensor(int32), tensor(int64)<br/> **S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))|
|SequenceInsert|*in* input_sequence:**S**<br/> *in* tensor:**T**<br/> *in* position:**I**<br/> *out* output_sequence:**S**|11+|**I** = tensor(int32), tensor(int64)<br/> **S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))|
|SequenceLength|*in* input_sequence:**S**<br/> *out* length:**I**|11+|**I** = tensor(int64)<br/> **S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))|
|Shape|*in* data:**T**<br/> *out* shape:**T1**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(int64)|
|||[1, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(int64)|
|Shrink|*in* input:**T**<br/> *out* output:**T**|9+|**T** = tensor(bfloat16), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Sigmoid|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|Sign|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[9, 12]|**T** = tensor(bfloat16), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|SimplifiedLayerNormalization|*in* X:**T**<br/> *in* scale:**T**<br/> *out* Y:**T**<br/> *out* inv_std_var:**U**|1+|**T** = tensor(double), tensor(float)|
|Sin|*in* input:**T**<br/> *out* output:**T**|7+|**T** = tensor(double), tensor(float)|
|SinGrad|*in* dY:**T**<br/> *in* X:**T**<br/> *out* dX:**T**|9+|**T** = tensor(float)|
|Sinh|*in* input:**T**<br/> *out* output:**T**|9+|**T** = tensor(float)|
|Size|*in* data:**T**<br/> *out* size:**T1**|13+|**T** = tensor(bool), tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(int64)|
|||[1, 12]|**T** = tensor(bool), tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(int64)|
|Slice|*in* data:**T**<br/> *in* starts:**Tind**<br/> *in* ends:**Tind**<br/> *in* axes:**Tind**<br/> *in* steps:**Tind**<br/> *out* output:**T**<br/> or<br/> *in* data:**T**<br/> *out* output:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||10|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|||[1, 9]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Softmax|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float)|
|||[11, 12]|**T** = tensor(double), tensor(float)|
|||[1, 10]|**T** = tensor(double), tensor(float)|
|SoftmaxCrossEntropyLoss|*in* scores:**T**<br/> *in* labels:**Tind**<br/> *in* weights:**T**<br/> *out* output:**T**<br/> *out* log_prob:**T**|13+|**T** = tensor(float)<br/> **Tind** = tensor(int32), tensor(int64)|
|||12|**T** = tensor(float)<br/> **Tind** = tensor(int32), tensor(int64)|
|Softplus|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Softsign|*in* input:**T**<br/> *out* output:**T**|1+|**T** = tensor(float)|
|SpaceToDepth|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(float)|
|||[1, 12]|**T** = tensor(float)|
|SparseSoftmaxCrossEntropy|*in* logits:**T**<br/> *in* label:**Tind**<br/> *in* weight:**T**<br/> *out* Y:**T**<br/> *out* log_prob:**T**|9+|**T** = tensor(float)|
|SparseSoftmaxCrossEntropyGrad|*in* dY:**T**<br/> *in* log_prob:**T**<br/> *in* label:**Tind**<br/> *in* weight:**T**<br/> *out* d_logits:**T**|9+|**T** = tensor(float)|
|Split|*in* input:**T**<br/> *in* split:**T**<br/> *out* outputs...:**T**<br/> or<br/> *in* input:**T**<br/> *in* split:**tensor(int64)**<br/> *out* outputs:**T**<br/> or<br/> *in* input:**T**<br/> *out* outputs:**T**|13+|**T** = tensor(float), tensor(int32), tensor(int64), tensor(string), tensor(uint8)|
|||[11, 12]|**T** = tensor(float), tensor(int32), tensor(int64), tensor(string), tensor(uint8)|
|||[2, 10]|**T** = tensor(float), tensor(int32), tensor(int64), tensor(string), tensor(uint8)|
|SplitToSequence|*in* input:**T**<br/> *in* split:**I**<br/> *out* output_sequence:**S**|11+|**I** = tensor(int32), tensor(int64)<br/> **S** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8))<br/> **T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(string)|
|Sqrt|*in* X:**T**<br/> *out* Y:**T**|13+|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|Squeeze|*in* data:**T**<br/> *in* axes:**tensor(int64)**<br/> *out* squeezed:**T**<br/> or<br/> *in* data:**T**<br/> *out* squeezed:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|StringNormalizer|*in* X:**tensor(string)**<br/> *out* Y:**tensor(string)**|10+|**T** = tensor(string)|
|Sub|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|14+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||13|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||[7, 12]|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|Sum|*in* data_0:**T**<br/> *out* sum:**T**|13+|**T** = tensor(double), tensor(float)|
|||[8, 12]|**T** = tensor(double), tensor(float)|
|||[6, 7]|**T** = tensor(double), tensor(float)|
|Tan|*in* input:**T**<br/> *out* output:**T**|7+|**T** = tensor(float)|
|Tanh|*in* input:**T**<br/> *out* output:**T**|13+|**T** = tensor(double), tensor(float)|
|||[6, 12]|**T** = tensor(double), tensor(float)|
|TfIdfVectorizer|*in* X:**T**<br/> *out* Y:**T1**|9+|**T** = tensor(int32), tensor(int64), tensor(string)<br/> **T1** = tensor(float)|
|ThresholdedRelu|*in* X:**T**<br/> *out* Y:**T**|10+|**T** = tensor(float)|
|||[1, 9]|**T** = tensor(float)|
|Tile|*in* input:**T**<br/> *in* repeats:**T1**<br/> *out* output:**T**<br/> or<br/> *in* input:**T**<br/> *in* tiles:**T**<br/> *in* axis:**T**<br/> *out* output:**T**|13+|**T** = tensor(bool), tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(int64)|
|||[6, 12]|**T** = tensor(bool), tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **T1** = tensor(int64)|
|TopK|*in* X:**T**<br/> *in* K:**tensor(int64)**<br/> *out* Values:**T**<br/> *out* Indices:**I**<br/> or<br/> *in* X:**T**<br/> *out* Values:**T**<br/> *out* Indices:**I**|11+|**I** = tensor(int64)<br/> **T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|||10|**I** = tensor(int64)<br/> **T** = tensor(double), tensor(float)|
|||[1, 9]|**I** = tensor(int64)<br/> **T** = tensor(double), tensor(float)|
|Transpose|*in* data:**T**<br/> *out* transposed:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Trilu|*in* input:**T**<br/> *in* k:**tensor(int64)**<br/> *out* output:**T**|14+|**T** = tensor(double), tensor(float), tensor(int64)|
|Unique|*in* X:**T**<br/> *out* Y:**T**<br/> *out* indices:**tensor(int64)**<br/> *out* inverse_indices:**tensor(int64)**<br/> *out* counts:**tensor(int64)**|11+|**T** = tensor(float), tensor(int64), tensor(int8), tensor(string)|
|Unsqueeze|*in* data:**T**<br/> *in* axes:**tensor(int64)**<br/> *out* expanded:**T**<br/> or<br/> *in* data:**T**<br/> *out* expanded:**T**|13+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[11, 12]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|||[1, 10]|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Upsample|*in* X:**T**<br/> *in* scales:**tensor(float)**<br/> *out* Y:**T**<br/> or<br/> *in* X:**T**<br/> *out* Y:**T**|9|**T** = tensor(float), tensor(int32), tensor(uint8)|
|||[7, 8]|**T** = tensor(float), tensor(int32), tensor(uint8)|
|Where|*in* condition:**B**<br/> *in* X:**T**<br/> *in* Y:**T**<br/> *out* output:**T**|9+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(string), tensor(uint8)|
|Xor|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T1**|7+|**T** = tensor(bool)<br/> **T1** = tensor(bool)|
| |
| |
|**Operator Domain:** *ai.onnx.ml*||||
|ArrayFeatureExtractor|*in* X:**T**<br/> *in* Y:**tensor(int64)**<br/> *out* Z:**T**|1+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(string)|
|Binarizer|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|CastMap|*in* X:**T1**<br/> *out* Y:**T2**|1+|**T1** = map(int64,tensor(float)), map(int64,tensor(string))<br/> **T2** = tensor(float), tensor(int64), tensor(string)|
|CategoryMapper|*in* X:**T1**<br/> *out* Y:**T2**|1+|**T1** = tensor(int64), tensor(string)<br/> **T2** = tensor(int64), tensor(string)|
|DictVectorizer|*in* X:**T1**<br/> *out* Y:**T2**|1+|**T1** = map(int64,tensor(double)), map(int64,tensor(float)), map(int64,tensor(string)), map(string,tensor(double)), map(string,tensor(float)), map(string,tensor(int64))<br/> **T2** = tensor(double), tensor(float), tensor(int64), tensor(string)|
|FeatureVectorizer|*in* X:**T1**<br/> *out* Y:**tensor(float)**|1+|**T1** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|Imputer|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float), tensor(int64)|
|LabelEncoder|*in* X:**T1**<br/> *out* Y:**T2**|2+|**T1** = tensor(float), tensor(int64), tensor(string)<br/> **T2** = tensor(float), tensor(int64), tensor(string)|
|||1|**T1** = tensor(int64), tensor(string)<br/> **T2** = tensor(int64), tensor(string)|
|LinearClassifier|*in* X:**T1**<br/> *out* Y:**T2**<br/> *out* Z:**tensor(float)**|1+|**T1** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(int64), tensor(string)|
|LinearRegressor|*in* X:**T**<br/> *out* Y:**tensor(float)**|1+|**T** = tensor(float)|
|Normalizer|*in* X:**T**<br/> *out* Y:**tensor(float)**|1+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|OneHotEncoder|*in* X:**T**<br/> *out* Y:**tensor(float)**|1+|**T** = tensor(double), tensor(float), tensor(int64), tensor(string)|
|SVMClassifier|*in* X:**T1**<br/> *out* Y:**T2**<br/> *out* Z:**tensor(float)**|1+|**T1** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(int64), tensor(string)|
|SVMRegressor|*in* X:**T**<br/> *out* Y:**tensor(float)**|1+|**T** = tensor(float)|
|Scaler|*in* X:**T**<br/> *out* Y:**tensor(float)**|1+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|TreeEnsembleClassifier|*in* X:**T1**<br/> *out* Y:**T2**<br/> *out* Z:**tensor(float)**|1+|**T1** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T2** = tensor(int64), tensor(string)|
|TreeEnsembleRegressor|*in* X:**T**<br/> *out* Y:**tensor(float)**|1+|**T** = tensor(double), tensor(float)|
|ZipMap|*in* X:**tensor(float)**<br/> *out* Z:**T**|1+|**T** = seq(map(int64,tensor(float))), seq(map(string,tensor(float)))|
| |
| |
|**Operator Domain:** *com.microsoft*||||
|ATenOp|*in* inputs:**T**<br/> *out* outputs:**T**|1+|**T** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8)), tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|ATenOpGrad|*in* inputs:**T**<br/> *out* outputs:**T**|1+|**T** = seq(tensor(bfloat16)), seq(tensor(bool)), seq(tensor(double)), seq(tensor(float)), seq(tensor(float16)), seq(tensor(int16)), seq(tensor(int32)), seq(tensor(int64)), seq(tensor(int8)), seq(tensor(string)), seq(tensor(uint16)), seq(tensor(uint32)), seq(tensor(uint64)), seq(tensor(uint8)), tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|AdamOptimizer|*in* R:**T1**<br/> *in* T:**T2**<br/> *in* weights:**T3**<br/> *in* gradients:**T_GRAD**<br/> *in* moment_1:**T4**<br/> *in* moment_2:**T4**<br/> *in* mixed_precision_weights:**T_MIXED_PRECISION_FP**<br/> *in* loss_scale:**T3**<br/> *in* global_gradient_norm:**T_GRAD_NORM**<br/> *in* update_signal:**T_BOOL**<br/> *out* new_T:**T2**<br/> *out* new_moment_1:**T4**<br/> *out* new_moment_2:**T4**<br/> *out* new_weights:**T3**<br/> *out* new_gradients:**T_GRAD**<br/> *out* new_mixed_precision_weights:**T_MIXED_PRECISION_FP**|1+|**T1** = tensor(float)<br/> **T2** = tensor(int64)<br/> **T3** = tensor(float)<br/> **T4** = tensor(float)<br/> **T_GRAD** = tensor(float)|
|Attention|*in* input:**T**<br/> *in* weight:**T**<br/> *in* bias:**T**<br/> *in* mask_index:**M**<br/> *in* past:**T**<br/> *out* output:**T**<br/> *out* present:**T**|1+|**T** = tensor(float)|
|AttnLSTM|*in* X:**T**<br/> *in* W:**T**<br/> *in* R:**T**<br/> *in* B:**T**<br/> *in* sequence_lens:**T1**<br/> *in* initial_h:**T**<br/> *in* initial_c:**T**<br/> *in* P:**T**<br/> *in* QW:**T**<br/> *in* MW:**T**<br/> *in* V:**T**<br/> *in* M:**T**<br/> *in* memory_seq_lens:**T1**<br/> *in* AW:**T**<br/> *out* Y:**T**<br/> *out* Y_h:**T**<br/> *out* Y_c:**T**|1+|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(int32)|
|BiasFastGeluGrad_dX|*in* dY:**T**<br/> *in* X:**T**<br/> *in* B:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|BiasGelu|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|1+|**T** = tensor(float)|
|BiasGeluGrad_dX|*in* dY:**T**<br/> *in* X:**T**<br/> *in* B:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|BroadcastGradientArgs|*in* a_shape:**T**<br/> *in* b_shape:**T**<br/> *out* a_axes:**T**<br/> *out* b_axes:**T**|1+|**T** = tensor(int64)|
|CDist|*in* A:**T**<br/> *in* B:**T**<br/> *out* C:**T**|1+|**T** = tensor(double), tensor(float)|
|ConcatTraining|*in* inputs:**T**<br/> *out* concat_result:**T**<br/> *out* per_input_length:**Tint**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|ConvGrad|*in* dY:**T**<br/> *in* X:**T**<br/> *in* W:**T**<br/> *out* dX:**T**<br/> *out* dW:**T**<br/> *out* dB:**T**|1+|**T** = tensor(float)|
|ConvTransposeWithDynamicPads|*in* X:**T**<br/> *in* W:**T**<br/> *in* Pads:**tensor(int64)**<br/> *in* B:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|CropAndResize|*in* X:**T1**<br/> *in* rois:**T1**<br/> *in* batch_indices:**T2**<br/> *in* crop_size:**T2**<br/> *out* Y:**T1**|1+|**T** = tensor(float)<br/> **T2** = tensor(int32)|
|DequantizeLinear|*in* x:**T1**<br/> *in* x_scale:**T2**<br/> *in* x_zero_point:**T1**<br/> *out* y:**T2**|1+|**T1** = tensor(int8), tensor(uint8)<br/> **T2** = tensor(float)|
|DropoutGrad|*in* dy:**T**<br/> *in* mask:**T2**<br/> *in* ratio:**T1**<br/> *in* training_mode:**T2**<br/> *out* dx:**T**|1+|**T** = tensor(double), tensor(float)<br/> **T1** = tensor(double), tensor(float), tensor(float16)<br/> **T2** = tensor(bool)|
|DynamicQuantizeLSTM|*in* X:**T**<br/> *in* W:**T2**<br/> *in* R:**T2**<br/> *in* B:**T**<br/> *in* sequence_lens:**T1**<br/> *in* initial_h:**T**<br/> *in* initial_c:**T**<br/> *in* P:**T**<br/> *in* W_scale:**T**<br/> *in* W_zero_point:**T2**<br/> *in* R_scale:**T**<br/> *in* R_zero_point:**T2**<br/> *out* Y:**T**<br/> *out* Y_h:**T**<br/> *out* Y_c:**T**|1+|**T** = tensor(float)<br/> **T1** = tensor(int32)<br/> **T2** = tensor(int8), tensor(uint8)|
|DynamicQuantizeMatMul|*in* A:**T1**<br/> *in* B:**T2**<br/> *in* b_scale:**T1**<br/> *in* b_zero_point:**T2**<br/> *in* bias:**T1**<br/> *out* Y:**T1**|1+|**T1** = tensor(float)<br/> **T2** = tensor(int8), tensor(uint8)|
|EmbedLayerNormalization|*in* input_ids:**T1**<br/> *in* segment_ids:**T1**<br/> *in* word_embedding:**T**<br/> *in* position_embedding:**T**<br/> *in* segment_embedding:**T**<br/> *in* gamma:**T**<br/> *in* beta:**T**<br/> *in* mask:**T1**<br/> *out* output:**T**<br/> *out* mask_index:**T1**|1+|**T** = tensor(float)|
|ExpandDims|*in* X:**T**<br/> *in* axis:**tensor(int32)**<br/> *out* Y:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **axis** = tensor(int32)|
|FastGelu|*in* X:**T**<br/> *in* bias:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|FastGeluGrad|*in* dY:**T**<br/> *in* X:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|FusedConv|*in* X:**T**<br/> *in* W:**T**<br/> *in* B:**T**<br/> *in* Z:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|FusedGemm|*in* A:**T**<br/> *in* B:**T**<br/> *in* C:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|FusedMatMul|*in* A:**T**<br/> *in* B:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|GatherElementsGrad|*in* dY:**T**<br/> *in* shape:**I**<br/> *in* indices:**Tind**<br/> *out* dX:**T**|1+|**T** = tensor(double), tensor(float)<br/> **Tind** = tensor(int32), tensor(int64)|
|GatherGrad|*in* shape:**I**<br/> *in* indices:**Tind**<br/> *in* dY:**T**<br/> *out* dX:**T**|1+|**I** = tensor(int64)<br/> **T** = tensor(double), tensor(float)<br/> **Tind** = tensor(int32), tensor(int64)|
|GatherND|*in* data:**T**<br/> *in* indices:**Tind**<br/> *out* output:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|GatherNDGrad|*in* shape:**T1**<br/> *in* indices:**Tind**<br/> *in* update:**T**<br/> *out* output:**T**|1+|**T** = tensor(double), tensor(float)<br/> **Tind** = tensor(int32), tensor(int64)|
|Gelu|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|GeluGrad|*in* dY:**T**<br/> *in* X:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|GistBinarizeDecoder|*in* X:**T1**<br/> *out* Y:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|GistBinarizeEncoder|*in* X:**T**<br/> *out* Y:**T1**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|Group|*in* input_tensors:**T**<br/> *out* done:**B**|1+|**B** = tensor(bool)<br/> **T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|InPlaceAccumulator|*in* old_sum:**T**<br/> *in* value:**T_GRAD**<br/> *in* update_signal:**T_BOOL**<br/> *out* new_sum:**T**|1+|**T** = tensor(float)|
|Inverse|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(double), tensor(float), tensor(float16)|
|InvertibleLayerNormalizationGrad|*in* Y_grad:**T**<br/> *in* Y:**T**<br/> *in* scale:**T**<br/> *in* bias:**T**<br/> *in* inv_std_var:**U**<br/> *out* X_grad:**T**<br/> *out* scale_grad:**T**<br/> *out* bias_grad:**T**|1+|**T** = tensor(double), tensor(float)|
|LayerNormalizationGrad|*in* Y_grad:**T**<br/> *in* X:**T**<br/> *in* scale:**T**<br/> *in* mean:**U**<br/> *in* inv_std_var:**U**<br/> *out* X_grad:**T**<br/> *out* scale_grad:**T**<br/> *out* bias_grad:**T**|1+|**T** = tensor(double), tensor(float)|
|LogSoftmaxGrad|*in* dY:**T**<br/> *in* X:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|MatMulInteger16|*in* A:**T1**<br/> *in* B:**T2**<br/> *out* Y:**T3**|1+|**T1** = tensor(int16)<br/> **T2** = tensor(int16)<br/> **T3** = tensor(int32)|
|MatMulIntegerToFloat|*in* A:**T1**<br/> *in* B:**T2**<br/> *in* a_scale:**T3**<br/> *in* b_scale:**T3**<br/> *in* a_zero_point:**T1**<br/> *in* b_zero_point:**T2**<br/> *in* bias:**T3**<br/> *out* Y:**T3**|1+|**T1** = tensor(uint8)<br/> **T2** = tensor(int8), tensor(uint8)<br/> **T3** = tensor(float)|
|MaxpoolWithMask|*in* X:**T**<br/> *in* M:**tensor(int32)**<br/> *out* Y:**T**|1+|**X** = tensor(float)|
|MurmurHash3|*in* X:**T1**<br/> *out* Y:**T2**|1+|**T1** = tensor(double), tensor(float), tensor(int32), tensor(int64), tensor(string), tensor(uint32), tensor(uint64)<br/> **T2** = tensor(int32), tensor(uint32)|
|NhwcMaxPool|*in* x:**T**<br/> *out* y:**T**|1+|**T** = tensor(uint8)|
|Pad|*in* data:**T**<br/> *in* pads:**tensor(int64)**<br/> *in* value:**T**<br/> *out* output:**T**|1+|**T** = tensor(float)|
|PassThrough|*in* inputs:**T**<br/> *out* outputs:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|QAttention|*in* input:**T1**<br/> *in* weight:**T2**<br/> *in* bias:**T3**<br/> *in* input_scale:**T3**<br/> *in* weight_scale:**T3**<br/> *in* mask_index:**T4**<br/> *in* input_zero_point:**T1**<br/> *in* weight_zero_point:**T2**<br/> *in* past:**T3**<br/> *out* output:**T3**<br/> *out* present:**T3**|1+|**T1** = tensor(uint8)<br/> **T2** = tensor(int8), tensor(uint8)<br/> **T3** = tensor(float)<br/> **T4** = tensor(int32)|
|QLinearAdd|*in* A:**T**<br/> *in* A_scale:**tensor(float)**<br/> *in* A_zero_point:**T**<br/> *in* B:**T**<br/> *in* B_scale:**tensor(float)**<br/> *in* B_zero_point:**T**<br/> *in* C_scale:**tensor(float)**<br/> *in* C_zero_point:**T**<br/> *out* C:**T**|1+|**T** = tensor(int8), tensor(uint8)|
|QLinearConv|*in* x:**T1**<br/> *in* x_scale:**tensor(float)**<br/> *in* x_zero_point:**T1**<br/> *in* w:**T2**<br/> *in* w_scale:**tensor(float)**<br/> *in* w_zero_point:**T2**<br/> *in* y_scale:**tensor(float)**<br/> *in* y_zero_point:**T3**<br/> *in* B:**T4**<br/> *out* y:**T3**|1+|**T1** = tensor(uint8)<br/> **T2** = tensor(int8), tensor(uint8)<br/> **T3** = tensor(uint8)<br/> **T4** = tensor(int32)|
|QLinearLeakyRelu|*in* X:**T**<br/> *in* X_scale:**tensor(float)**<br/> *in* X_zero_point:**T**<br/> *in* Y_scale:**tensor(float)**<br/> *in* Y_zero_point:**T**<br/> *out* Y:**T**|1+|**T** = tensor(int8), tensor(uint8)|
|QLinearMul|*in* A:**T**<br/> *in* A_scale:**tensor(float)**<br/> *in* A_zero_point:**T**<br/> *in* B:**T**<br/> *in* B_scale:**tensor(float)**<br/> *in* B_zero_point:**T**<br/> *in* C_scale:**tensor(float)**<br/> *in* C_zero_point:**T**<br/> *out* C:**T**|1+|**T** = tensor(int8), tensor(uint8)|
|QLinearSigmoid|*in* X:**T**<br/> *in* X_scale:**tensor(float)**<br/> *in* X_zero_point:**T**<br/> *in* Y_scale:**tensor(float)**<br/> *in* Y_zero_point:**T**<br/> *out* Y:**T**|1+|**T** = tensor(int8), tensor(uint8)|
|QuantizeLinear|*in* x:**T1**<br/> *in* y_scale:**T1**<br/> *in* y_zero_point:**T2**<br/> *out* y:**T2**|1+|**T1** = tensor(float)<br/> **T2** = tensor(int8), tensor(uint8)|
|Range|*in* start:**T**<br/> *in* limit:**T**<br/> *in* delta:**T**<br/> *out* Y:**T**|1+|**T** = tensor(double), tensor(float), tensor(int16), tensor(int32), tensor(int64)|
|RecordEvent|*in* EventIdentifier:**TInt64**<br/> *in* InputData:**T**<br/> *out* OutputData:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **TInt64** = tensor(int64)|
|ReduceAllL2|*in* X:**TIn**<br/> *out* Y:**TOut**|1+|**TIn** = tensor(float)<br/> **TOut** = tensor(float)|
|ReduceSumTraining|*in* data:**T**<br/> *in* axes:**tensor(int64)**<br/> *out* reduced:**T**|1+|**T** = tensor(double), tensor(float), tensor(int32), tensor(int64)|
|ReluGrad|*in* dY:**T**<br/> *in* X:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|SGDOptimizer|*in* ETA:**L**<br/> *in* W:**T**<br/> *in* G:**T**<br/> *out* NW:**T**<br/> *out* NG:**T**|1+|**T** = tensor(float)|
|SampleOp|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Scale|*in* input:**T**<br/> *in* scale:**ScaleT**<br/> *out* output:**T**|1+|**ScaleT** = tensor(double), tensor(float), tensor(int32), tensor(int64)<br/> **T** = tensor(double), tensor(float)|
|SimplifiedLayerNormalizationGrad|*in* Y_grad:**T**<br/> *in* X:**T**<br/> *in* scale:**T**<br/> *in* inv_std_var:**U**<br/> *out* X_grad:**T**<br/> *out* scale_grad:**T**|1+|**T** = tensor(double), tensor(float)|
|SkipLayerNormalization|*in* input:**T**<br/> *in* skip:**T**<br/> *in* gamma:**T**<br/> *in* beta:**T**<br/> *in* bias:**T**<br/> *out* output:**T**<br/> *out* mean:**U**<br/> *out* inv_std_var:**U**|1+|**T** = tensor(double), tensor(float)|
|SliceGrad|*in* dY:**T**<br/> *in* shape:**I**<br/> *in* starts:**Tind**<br/> *in* ends:**Tind**<br/> *in* axes:**Tind**<br/> *in* steps:**Tind**<br/> *out* dX:**T**|1+|**I** = tensor(int64)<br/> **T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **Tind** = tensor(int32), tensor(int64)|
|SoftmaxCrossEntropy|*in* logits:**T**<br/> *in* label:**T**<br/> *out* Y:**T**<br/> *out* log_prob:**T**|1+|**T** = tensor(float)|
|SoftmaxCrossEntropyGrad|*in* dY:**T**<br/> *in* log_prob:**T**<br/> *in* label:**T**<br/> *out* d_logits:**T**|1+|**T** = tensor(float)|
|SoftmaxCrossEntropyLossGrad|*in* dY:**T**<br/> *in* log_prob:**T**<br/> *in* label:**Tind**<br/> *in* weight:**T**<br/> *out* d_logits:**T**|1+|**T** = tensor(float)<br/> **Tind** = tensor(int32), tensor(int64)|
|SoftmaxGrad|*in* dY:**T**<br/> *in* Y:**T**<br/> *out* dX:**T**|1+|**T** = tensor(float)|
|SplitTraining|*in* input:**T**<br/> *in* split:**tensor(int64)**<br/> *out* outputs:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|SummaryHistogram|*in* input:**T**<br/> *out* summary:**S**|1+|**S** = tensor(string)<br/> **T** = tensor(double), tensor(float)|
|SummaryMerge|*in* input:**S**<br/> *out* summary:**S**|1+|**S** = tensor(string)|
|SummaryScalar|*in* input:**T**<br/> *out* summary:**S**|1+|**S** = tensor(string)<br/> **T** = tensor(bool), tensor(double), tensor(float)|
|SummaryText|*in* input:**S**<br/> *out* summary:**S**|1+|**S** = tensor(string)|
|Tokenizer|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(string)|
|TransposeMatMul|*in* A:**T**<br/> *in* B:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Trilu|*in* X:**T**<br/> *in* k:**tensor(int64)**<br/> *out* Y:**T**|1+|**T** = tensor(double), tensor(float), tensor(int64)|
|Unique|*in* x:**T**<br/> *out* y:**T**<br/> *out* idx:**tensor(int64)**<br/> *out* counts:**tensor(int64)**|1+|**T** = tensor(float)|
|WaitEvent|*in* EventIdentifier:**TInt64**<br/> *in* InputData:**T**<br/> *out* OutputData:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)<br/> **TInt64** = tensor(int64)|
|WordConvEmbedding|*in* Sequence:**T**<br/> *in* W:**T1**<br/> *in* B:**T1**<br/> *in* C:**T1**<br/> *out* Y:**T1**|1+|**T** = tensor(int32)<br/> **T1** = tensor(float)|
|YieldOp|*in* module_outputs:**T**<br/> *out* module_outputs_grad:**T**|1+|**T** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
|ZeroGradient|*in* old_gradient:**T1**<br/> *in* reset_signal:**T2**<br/> *out* zero_gradient:**T1**|1+|**T1** = tensor(float)<br/> **T2** = tensor(bfloat16), tensor(bool), tensor(double), tensor(float), tensor(float16), tensor(int16), tensor(int32), tensor(int64), tensor(int8), tensor(string), tensor(uint16), tensor(uint32), tensor(uint64), tensor(uint8)|
| |
| |
|**Operator Domain:** *com.microsoft.nchwc*||||
|AveragePool|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Conv|*in* X:**T**<br/> *in* W:**T**<br/> *in* B:**T**<br/> *in* Sum:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|GlobalAveragePool|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|GlobalMaxPool|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|MaxPool|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|ReorderInput|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|ReorderOutput|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
|Upsample|*in* X:**T**<br/> *out* Y:**T**|1+|**T** = tensor(float)|
| |
| |
